Yes—aside from the VM switch you already made, the **rest are necessary** to prevent prod-time crashes and import/init order bugs. Here’s the **trimmed list (no VM change)**:

## Required changes (keep behavior identical, fix crashes)

1. **`package.json` – runtime deps & scripts**

* Add `pg` (needed by `connect-pg-simple`).
* Solid build/start scripts and ESM entry.

```json
{
  "type": "module",
  "dependencies": { "pg": "^8.12.0" },
  "scripts": {
    "build:client": "vite build",
    "build:server": "esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outfile=dist/server/index.mjs",
    "build": "npm run build:client && npm run build:server",
    "start": "node dist/server/index.mjs"
  }
}
```

2. **`server/vite.ts` – dev-only, dynamic imports (no top-level `vite`)**

```ts
export async function setupVite(app, _server) {
  const { createServer } = await import("vite");
  const vite = await createServer({ root: "client", server: { middlewareMode: true }, appType: "custom" });
  app.use(vite.middlewares);
}
```

> Ensures the prod server never tries to load `vite`/dev plugins.

3. **`vite.config.ts` – gate dev plugins; avoid eager imports**

```ts
export default defineConfig(async ({ mode }) => {
  const plugins = [react()];
  if (mode !== "production" && process.env.REPL_ID) {
    const [{ cartographer }, overlay] = await Promise.all([
      import("@replit/vite-plugin-cartographer"),
      import("@replit/vite-plugin-runtime-error-modal")
    ]);
    plugins.push(cartographer(), overlay.default());
  }
  return { plugins, root: "client", build: { outDir: "dist/public", emptyOutDir: true } };
});
```

4. **`server/db.ts` – lazy DB init; no module-time throws**

```ts
let pool = null, dbInstance = null;
export function getDb() {
  if (dbInstance) return dbInstance;
  const url = process.env.DATABASE_URL;
  if (!url) throw new Error("DATABASE_URL must be set");
  neonConfig.webSocketConstructor = ws;
  pool = new Pool({ connectionString: url });
  dbInstance = drizzle(pool, { schema });
  return dbInstance;
}
export async function closeDatabase() { if (pool) await pool.end(); }
```

5. **`server/utils/db-indexes.ts` – accept a DB param**

* Change to `export async function createDatabaseIndexes(db) { … }` (don’t import `db` at module top).

6. **`server/routes.ts` (and any DB users) – get DB at runtime**

```ts
export function registerRoutes(app) {
  const db = getDb(); // call inside the function, not at import time
  // routes...
}
```

7. **`server/index.ts` – load env first; dev/prod split; serve static in prod**

```ts
import "dotenv/config";
const IS_DEPLOYMENT = process.env.REPLIT_DEPLOYMENT === "true";
...
registerRoutes(app);
if (app.get("env") === "development" && !IS_DEPLOYMENT) {
  await setupVite(app, server);
} else {
  app.use(express.static("dist/public"));
  app.get("*", (_req, res) => res.sendFile(path.join("dist/public", "index.html")));
}
const db = getDb();
await createDatabaseIndexes(db);
server.listen(process.env.PORT || 3000);
process.on("SIGTERM", async () => { await closeDatabase(); process.exit(0); });
```

## Optional / contextual (recommended)

8. **`server/storage.ts` – guard session store on env**

* Only construct the `connect-pg-simple` store if `DATABASE_URL` exists. (Still keep `pg` installed to satisfy its `require`.)

9. **Sanity checks**

* Nowhere in server code should import `vite` or `vite.config` at top level.
* Any env reads that can run at import time should be moved inside functions.

If you want this as a minimal patch/PR touching just these files, say the word and I’ll draft it inline.
