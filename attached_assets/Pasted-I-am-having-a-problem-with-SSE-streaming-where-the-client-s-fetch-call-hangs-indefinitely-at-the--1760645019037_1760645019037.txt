I am having a problem with SSE streaming where the client's fetch() call hangs indefinitely at the 
  /api/chatbot/stream-sse endpoint. The fetch promise never resolves, preventing the ReadableStream from being
  established, even though server logs show chunks being sent successfully. Please fix it by:

  Step 1: Review and identify the root cause
  - Check server/routes.ts around line 1926 (the SSE endpoint where headers are set)
  - Search the entire codebase for all occurrences of (res as any).flush()
  - Verify that this pattern exists in at least 5 locations throughout the file

  Step 2: Apply the critical fix
  - In the SSE chatbot endpoint (/api/chatbot/stream-sse around line 1926), replace:
  if ((res as any).flush) {
    (res as any).flush();
  }
  - with:
  res.flushHeaders();

  Step 3: Fix the bulk refresh endpoint
  - Find the bulk refresh SSE endpoint (around line 4016)
  - Apply the same fix: replace (res as any).flush() with res.flushHeaders()

  Step 4: Remove redundant flush calls
  - Remove the flush calls in the streaming loop at approximately:
    - Line 2246 (error handling)
    - Line 2305 (done message)
    - Line 2322 (chunk sending)
  - These are unnecessary because Node.js automatically flushes after flushHeaders() is called

  Step 5: Verify the fix
  - Search the codebase again for (res as any).flush and confirm 0 occurrences remain
  - Restart the development server
  - Test the SSE endpoint by triggering an incorrect answer in the chatbot

  Because:

  - Express/Node.js response objects don't have a .flush() method - the correct method is res.flushHeaders()
  - The conditional if ((res as any).flush) always evaluates to false (the method doesn't exist) and fails silently
  with no error thrown
  - Without calling res.flushHeaders(), the HTTP status code and headers are buffered and never sent to the client
  - When headers aren't sent, the client's fetch() promise hangs indefinitely waiting for the response headers
  - This creates a disconnect: server logs show "success" (data goes into Node's internal buffer) but the client never
  receives anything (no HTTP response established)
  - Once res.flushHeaders() sends the initial headers, Node.js automatically flushes subsequent res.write() calls,
  making additional flush calls redundant"