Here’s the simplest, reliable path for a Flutter WebView:

**Use `@dnd-kit` (Pointer Events under the hood).**
No HTML5 DnD. Add `touch-action: none` on the draggable, done.

### 5-step plan

1. `npm i @dnd-kit/core`
2. Wrap your page in `<DndContext sensors={[PointerSensor]}>`
3. Make drop zones with `useDroppable({ id })`
4. Make items with `useDraggable({ id })`
5. Add a `<DragOverlay>` for the ghost; put `touch-action: none` on the draggable element

### Tiny starter (React/TS)

```tsx
import React from "react";
import {
  DndContext, PointerSensor, useSensor, useSensors,
  useDroppable, useDraggable, DragOverlay, closestCenter
} from "@dnd-kit/core";

type Col = "todo" | "done";

export default function Board() {
  const [items, setItems] = React.useState<Record<Col, string[]>>({
    todo: ["A", "B", "C"], done: ["D"]
  });
  const [activeId, setActiveId] = React.useState<string | null>(null);

  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 8 } }));

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={({ active }) => setActiveId(String(active.id))}
      onDragEnd={({ active, over }) => {
        setActiveId(null);
        if (!over) return;
        const from = (["todo","done"] as Col[]).find(c => items[c].includes(String(active.id)));
        const to = over.id as Col;
        if (!from || from === to) return;
        setItems(s => ({ ...s,
          [from]: s[from].filter(x => x !== active.id),
          [to]:   [...s[to], String(active.id)]
        }));
      }}
    >
      <div className="board">
        <Zone id="todo" title="To do">{items.todo.map(id => <Item key={id} id={id} />)}</Zone>
        <Zone id="done" title="Done">{items.done.map(id => <Item key={id} id={id} />)}</Zone>
      </div>
      <DragOverlay>{activeId ? <Card id={activeId} /> : null}</DragOverlay>
    </DndContext>
  );
}

function Zone({ id, title, children }: { id: Col; title: string; children: React.ReactNode }) {
  const { setNodeRef, isOver } = useDroppable({ id });
  return <div ref={setNodeRef} className={`zone ${isOver ? "over" : ""}`}><h3>{title}</h3>{children}</div>;
}

function Item({ id }: { id: string }) {
  const { attributes, listeners, setNodeRef, transform, isDragging } = useDraggable({ id });
  return (
    <div
      ref={setNodeRef}
      {...listeners} {...attributes}
      style={{
        transform: transform ? `translate3d(${transform.x}px, ${transform.y}px, 0)` : undefined,
        touchAction: "none", userSelect: "none", WebkitUserSelect: "none",
        opacity: isDragging ? 0 : 1
      }}
    >
      <Card id={id} />
    </div>
  );
}

function Card({ id }: { id: string }) {
  return <div className="card"><span className="grip" aria-hidden>⋮⋮</span>{id}</div>;
}
```

**CSS (minimal)**

```css
.board { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.zone { min-height: 220px; padding: 12px; border-radius: 12px; background:#f6f7f9; }
.zone.over { outline: 2px dashed #7aa7ff; outline-offset: 4px; }
.card { padding:12px; margin:8px 0; border-radius:10px; background:#fff; box-shadow:0 1px 4px rgba(0,0,0,.08); display:flex; align-items:center; gap:8px; }
.grip { cursor: grab; }
```

**That’s it.** Works in iOS/Android WebView, scroll stays normal, drags are smooth. If you want a no-library version later, I can give a 20-line pointer-events pattern.
