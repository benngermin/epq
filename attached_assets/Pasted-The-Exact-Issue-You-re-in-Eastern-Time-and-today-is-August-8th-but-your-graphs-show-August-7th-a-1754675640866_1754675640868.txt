The Exact Issue

  You're in Eastern Time and today is August 8th, but your graphs show August 7th as the latest date. The problem is that the getTodayEST() function is incorrectly calculating what "midnight
  Eastern Time today" means in UTC format.

  The Specific Bug

  In /server/utils/logger.ts, the getTodayEST() function creates this string:
  return new Date(`${easternDateStr}T0${offsetHours}:00:00.000Z`);

  When easternDateStr is "2025-08-08" and offsetHours is 4 (for EDT), this creates:
  "2025-08-08T04:00:00.000Z"

  This is WRONG because:
  - 2025-08-08T04:00:00.000Z means 4 AM UTC on August 8th
  - When converted to Eastern Time, this is midnight on August 8th
  - BUT the database thinks this represents the START of August 8th when it's actually already 4 hours into August 8th UTC

  The Fix

  Replace the getTodayEST() function with this:

  export function getTodayEST(): Date {
    // Get current moment in Eastern Time
    const now = new Date();

    // Get today's date string in Eastern Time (YYYY-MM-DD format)
    const easternDateStr = now.toLocaleDateString("en-CA", {
      timeZone: "America/New_York"
    });

    // For Eastern Time midnight, we need to subtract the offset from UTC
    // EDT = UTC-4, EST = UTC-5
    // So midnight ET on Aug 8 = Aug 8 04:00 UTC (for EDT)

    // Check if we're in DST
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: 'America/New_York',
      timeZoneName: 'short'
    });

    const parts = formatter.formatToParts(now);
    const tzName = parts.find(p => p.type === 'timeZoneName')?.value || 'EST';
    const isDST = tzName.includes('EDT') || tzName.includes('Eastern Daylight');
    const offsetHours = isDST ? 4 : 5;

    // Create the date properly: midnight ET as a UTC timestamp
    // We pad the offset to ensure proper formatting (04 not 4)
    const paddedOffset = offsetHours.toString().padStart(2, '0');
    return new Date(`${easternDateStr}T${paddedOffset}:00:00.000Z`);
  }

  And do the same for getDateAtMidnightEST():

  export function getDateAtMidnightEST(date: Date): Date {
    // Get the date string in Eastern timezone
    const easternDateStr = date.toLocaleDateString("en-CA", {
      timeZone: "America/New_York"
    });

    // Check if DST is active for this date
    const formatter = new Intl.DateTimeFormat('en-US', {
      timeZone: 'America/New_York',
      timeZoneName: 'short'
    });

    const parts = formatter.formatToParts(date);
    const tzName = parts.find(p => p.type === 'timeZoneName')?.value || 'EST';
    const isDST = tzName.includes('EDT') || tzName.includes('Eastern Daylight');
    const offsetHours = isDST ? 4 : 5;

    // Create the date properly with padded offset
    const paddedOffset = offsetHours.toString().padStart(2, '0');
    return new Date(`${easternDateStr}T${paddedOffset}:00:00.000Z`);
  }

  Why This Fixes It

  The current code creates T04:00:00 (using T0${offsetHours}) which seems right but the string concatenation "T0" + 4 gives "T04" which is correct. However, the issue is that this represents 4
  AM UTC on August 8th, which when the database queries compare dates, it treats this as the beginning of August 8th UTC, but your PostgreSQL queries are comparing in Eastern Time where this is
   actually midnight.

  The real issue is that the function works correctly for the timezone math but the way it's being used in the SQL queries expects a different representation. The dates need to align with how
  PostgreSQL interprets them when using AT TIME ZONE 'America/New_York'.

