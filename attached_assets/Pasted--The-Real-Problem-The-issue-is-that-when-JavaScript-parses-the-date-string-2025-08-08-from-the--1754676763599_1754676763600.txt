 The Real Problem

  The issue is that when JavaScript parses the date string "2025-08-08" from the backend, it interprets it as midnight UTC, not midnight Eastern Time. Here's what's happening:

  1. Backend returns: "2025-08-08" (a string)
  2. Frontend creates Date object: new Date("2025-08-08")
  3. JavaScript interprets this as: August 8, 2025 at 00:00 UTC
  4. When formatted in Eastern Time: This becomes August 7, 2025 at 8:00 PM EDT

  The Fix

  The problem is in /client/src/components/app-logs-section.tsx in the formatDateLabel function (line 192-202):

  const formatDateLabel = (dateStr: string, groupBy: 'day' | 'week' | 'month') => {
    const date = new Date(dateStr);  // <-- THIS IS THE PROBLEM
    // ...
  }

  When you do new Date("2025-08-08"), JavaScript assumes UTC timezone. Since you're in Eastern Time (UTC-4 during summer), this gets displayed as the previous day.

  The Solution

  Change the formatDateLabel function to:

  const formatDateLabel = (dateStr: string, groupBy: 'day' | 'week' | 'month') => {
    // Parse the date string as Eastern Time, not UTC
    // Append a time and timezone to force Eastern Time interpretation
    const date = new Date(dateStr + 'T00:00:00-04:00'); // EDT offset

    switch(groupBy) {
      case 'week':
        return format(date, 'MMM dd');
      case 'month':
        return format(date, 'MMM yyyy');
      default:
        return format(date, 'MMM dd');
    }
  };

  Or, even simpler, since the date string from backend is already correct, just format it directly without creating a Date object:

  const formatDateLabel = (dateStr: string, groupBy: 'day' | 'week' | 'month') => {
    // dateStr is "2025-08-08" format
    const [year, month, day] = dateStr.split('-');
    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    switch(groupBy) {
      case 'week':
        return `${monthNames[parseInt(month) - 1]} ${parseInt(day)}`;
      case 'month':
        return `${monthNames[parseInt(month) - 1]} ${year}`;
      default:
        return `${monthNames[parseInt(month) - 1]} ${parseInt(day)}`;
    }
  };

  The root cause is that JavaScript's new Date("2025-08-08") interprets the date as UTC midnight, which when displayed in Eastern Time becomes the previous day. The backend is sending the
  correct date string, but the frontend is misinterpreting it due to timezone assumptions.

