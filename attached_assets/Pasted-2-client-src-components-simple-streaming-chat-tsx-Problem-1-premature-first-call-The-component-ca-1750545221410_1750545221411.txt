2. client/src/components/simple-streaming-chat.tsx
Problem 1 – premature first call
The component calls loadAiResponse() in a mount‑only useEffect([]).
If the first prop value of chosenAnswer is empty (which happened before the preceding patch), the assistant is called with an empty answer and never re‑fires.

Problem 2 – follow‑up turns sometimes stall
loadAiResponse() bails out early when it is already streaming, but it never aborts / resets abortControllerRef between runs, so a quick second click can leave the controller in an “aborted” state and the poller stops.

Patch
diff
Copy
@@
-  // Update the ref when chosenAnswer changes
+  // Keep a *stable* reference to the learner's first submitted answer
   useEffect(() => {
-    console.log("chosenAnswer prop changed:", JSON.stringify(chosenAnswer), "type:", typeof chosenAnswer);
-    if (chosenAnswer) {
-      originalChosenAnswerRef.current = chosenAnswer;
-      console.log("Updated originalChosenAnswerRef to:", chosenAnswer);
-    }
+    if (chosenAnswer) {
+      originalChosenAnswerRef.current = chosenAnswer;
+    }
   }, [chosenAnswer]);
 
-  useEffect(() => {
-    if (!hasResponse) {
-      loadAiResponse();
-    }
-  }, []);
+  /* -----------------------------------------------------------
+   * Trigger the assistant *only when we actually have an answer*,
+   * or when the question itself changes.
+   * --------------------------------------------------------- */
+  useEffect(() => {
+    if (chosenAnswer && !hasResponse) {
+      // reset old conversation if we switched questions
+      setMessages([]);
+      abortControllerRef.current?.abort?.();
+      abortControllerRef.current = null;
+
+      loadAiResponse();            // first assistant explanation
+    }
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [questionVersionId, chosenAnswer]);
diff
Copy
@@   const loadAiResponse = async (userMessage?: string) => {
-    // Always use the original chosen answer for consistency
-    const finalChosenAnswer = originalChosenAnswerRef.current || chosenAnswer || "";
+    /* Guard against accidental empty submissions */
+    const finalChosenAnswer =
+      originalChosenAnswerRef.current || chosenAnswer || "";
+    if (!finalChosenAnswer && !userMessage) {
+      console.warn(
+        "Aborting AI call – no chosen answer or user message available"
+      );
+      return;
+    }
@@
-      while (!done && !abortControllerRef.current?.signal.aborted) {
+      while (!done && !(abortControllerRef.current?.signal?.aborted ?? false)) {
         /* polling loop unchanged */
       }
